欢迎使用汉字自动拆分系统「拆」！

# 用户文档

## 安装

您可以在 PyPI 上下载汉字自动拆分系统：

```bash
pip3 install Chai.py
```

该系统依赖 PyYAML，您可以手动安装（`pip3 install PyYAML`）也可以在安装「拆」时自动安装。

## 配置文件编写

由于「拆」的高度模块化特性，您可以通过编写简单的配置文件的方式来指定一个输入方案的绝大部分信息。您可以在安装目录下看到预置的三个方案配置文件；您也可以稍后在 Python 脚本中访问。让我们以 98 五笔 `wubi98.schema.yaml` 为例进行解说。

### 理解 `schema`

配置文件的第一部分是方案基本信息。这一部分不会对方案的制作产生影响，但出于方便交流考虑，建议您留下您的个人信息。例如：

```yaml
schema:
  name: 五笔字型 98 版
  version: "0.1"
  author:
    - 发明人 王永民
    - 重建人 蓝落萧 2320693692@qq.com
  description: |
    用于测试自动拆分
```

---

下面我们来指定方案的拆分规则。

### 理解 `degenerator`

`degenerator` 者，中文名曰「退化映射」也。退化映射是本系统最重要的概念，没有之一。这是因为：「拆」的数据库中精确存储了汉字的图形信息，退化映射决定了您希望不同的图形在何种程度上可以被视为同一个字根。例如：

```yaml
degenerator:
  - 笔画序列
  - 笔画拓扑
```

笔画序列的含义是，当待拆分的汉字中含有与给定字根相同的笔画顺序时，我们才能够从该字中拆出给定的字根。例如，对于「月」字根，「用」字中包含该字根，而「青」字中不含有该字根，因为「青」的下部第一笔为「竖」。

笔画拓扑的含义是，在笔画序列的基础上，我们还要进一步考虑笔画之间的关系。例如，「工」和「土」具有完全相同的笔画序列，但「土」的第一二笔为相交关系，「工」为相连关系，它们并不相同。添加「笔画拓扑」之后，这种情况就能够得以区分。

目前，我们仅预设了这两个组件，如果您希望指定更细致的退化映射，请您了解开发者文档并进行相关算法的编写。

### 理解 `selector`

`selector` 者，中文名曰「择优函数」也。经过 `degenerator` 处理后，我们得到了汉字的多种可能拆分方式。此时，我们根据一系列规则确定选取哪种拆分方式。例如：

```yaml
selector:
  - 根少优先
  - 笔顺优先
  - 取大优先
```

- 根少优先，即拆出的字根数应该尽量少。
- 笔顺优先，即拆分应该尽可能符合笔顺。
- 取大优先，即拆分出的字根排在前面的笔画应该尽量多。

同样，我们目前仅预设了这三个组件，如果您希望指定更细致的择优函数，请您了解开发者文档并进行相关算法的编写。

值得注意的是，`degenerator` 各组件的顺序对拆分结果无影响，但 `selector` 各组件的顺序对拆分结果有影响。作为实例，请考虑「平」的拆分：给定字根「一、丷、十、干」，若组件的顺序如上，则拆为「干、丷」；若「笔顺优先」调整到最前面，则拆为「一、丷、十」。

那么，我们如何确定我们给出的规则一定能确定唯一的拆分方式呢？对于这个问题我们没有一般的回答，但可以证明，当「笔顺优先」和「取大优先」均出现（不管顺序如何，也不管有什么其他的组件）时，能确定唯一的拆分方式。因此，如果您没有详细地考虑过其余选择方案的唯一性，建议保证包含这两者。

拆分规则至此结束，下面我们来指定方案的字根。

---

### 理解 `classifier`

我们注意到，许多方案将汉字的笔画进行了分类，这使得作者和用户可以笼统地掌握笔画而不用掌握每一种情况。在国家标准黑体类字形中，笔画共有 31 种，但绝大多数方案将它们分为 5 至 7 类。最流行的划分方案是国家标准、五笔、二笔等采用的五分法：

```yaml
classifier:
  1: [横, 提]
  2: [竖, 竖钩]
  3: [撇]
  4: [点, 捺]
  5: [横钩, 横撇, 横折, 横折钩, 横斜钩, 横折提, 横折折, 横折弯, 横撇弯钩, 横折弯钩, 横折折撇, 横折折折, 横折折折钩, 
      竖提, 竖折, 竖弯, 竖弯钩, 竖折撇, 竖折折钩, 竖折折, 
      撇点, 撇折, 弯钩, 斜钩]
```

进行分类意味着同一类中的笔画将放置在相同的键位上。

### 理解 `mapper`

在这一步，我们将字根映射到指定的键位上。例如：

```yaml
mapper:
  g: [1, 11, 王, 青上, 五, 夫, 夫上, 举下, 年下, 舛右]
  ...
  x: [幺, 双折, 纟, 母, 彖上, 贯上, 弓, 匕, 化右, 比左]
```

这里「键位」不一定需要为实体按键，也可以是虚拟的键名。作为实例，请参考 `fingertip.schema.yaml`。

### 理解 `aliaser`

您可能已经注意到了：在 `map` 中，字根分为两类：

- 一类为单个字符，如「王」；
- 一类为多个字符，如「年下」；

单个字符所描述的字根就是它本身，而多个字符所描述的字根是非成字字根，可以任意命名。那么，我们何从知道多个字符描述的具体是什么字根呢？这就需要通过「别名注册器」进行注册：

```yaml
aliaser:
  ...
  年下: [年, [2, ..., 5]]
  ...
```

这里，我们指定「年下」是由「年」的第 2 笔至第 5 笔构成的字根。这样，系统通过结合图形数据，即可知道「年下」的形状如何了。

您可能注意到，有一部分多个字符描述的字根无需注册。这是因为，这些名称已经是数据库中存储基本部件时使用的名称。您可以在安装文件夹中打开 `文.yaml` 或 `字.yaml` 找出您所需要的名称，如果没有发现再进行定义。

## 码表输出

然而，仅仅编写配置文件并不能满足每个人对于取码编码的不同需求。因此，本系统仍然要求使用者编写一定量的代码（小于五十行）来自定义编码工作。下面我们就来看一下在拆分结束后用户如何取码。

### 读入方案

安装好 `Chai.py` 后，我们需要在自己的文件中导入 `Schema` 类，用它读入自己的方案（这里以 `wubi98` 为例），运行拆分：

```python
from Chai import Schema

wubi98 = Schema('wubi98')
wubi98.run()
```

当 `Schema('wubi98')` 执行时，系统会首先查看当前文件夹（也就是这行语句所在的程序所在的文件夹）是否含有 `wubi98.schema.yaml`，如果没有，则在内置文件夹中寻找。由于 `Schema` 是一个类，这个操作相当于实例化一个 `Schema` 对象，我们将其命名为 `wubi98`。

然后，`wubi98.run()` 则代表的是根据配置文件中所包含的拆分规则和字根选取运行拆分。取决于您的字集大小和拆分规则，这一过程可能会耗时 5 至 10 秒。

### 理解 `Schema.component` 属性

运行结束后，`wubi98` 对象将会生成一个 `wubi98.component` 属性，它的结构如下：

```python
{
    nameChar1: (objectRoot1, objectRoot2, ...),
    ...
}
```

其中，`nameChar` 是「名义字」，即一个字符串，如 `'的'`。而 `objectRoot1, ...` 则是「对象字根」，它们是自定义类 `Char` 的实例。我们接下来就会看到如何利用这些 `Char` 类对象进行编码。

但在这之前，我们有必要提醒读者：`wubi98.run()` 并没有生成所有字的拆分，而是生成了所有「基本部件」的拆分。例如「里」是一个基本部件，它是 `wubi98.component` 的键之一，但「理」、「锂」等并不在 `wubi98.component` 中。它们的拆法由下面给出的办法定义：

### 理解 `Schema.tree` 属性

例如，`wubi98.tree` 的结构如下：

```python
{
    nameChar1: tree1
    ...
}
```

其中 `nameChar` 和上面相同，而 `tree` 则是一个自定义类 `Tree` 的实例。`Tree` 具有如下属性：

- `Tree.name`：字名，例如「理」；
- `Tree.structure`：字的结构，例如「理」为左右结构，代码为 `h`；
- `Tree.first` 和 `Tree.second`：字按该结构进行二分之后，得到的第一部分（如王）和第二部分（如理）。

注意，这些部分仍然是一个 `Tree` 对象，如此不断迭代拆分，直到不可再分（即某一部分为基本部件）为止，此时基本部件对应的 `Tree` 的 `first` 和 `second` 属性均为 `None`，其结构为空。

### 顺序风格编码

这里，「顺序风格」指的是类似于五笔的顺序取字根的方式。此时，基本部件按顺序拆分，而其他字先表示为基本部件的序列，然后依次取各个部件的拆分，再合并到一起。这种取码方式用代码表达就是：

```python
for nameChar in wubi98.charList:
    if nameChar in wubi98.component:
        scheme = wubi98.component[nameChar]
    else:
        tree = wubi98.tree[nameChar]
        componentList = tree.flatten()
        scheme = sum((wubi98.component[component] for component in componentList), tuple())
```

在这里，我们获得合体字的树后，将其打平（`Tree.flatten()`）为基本部件的列表，它不含有任何嵌套；然后再将各个基本部件的拆分连接起来。显然此时 `scheme` 是一个含有若干「对象字根」的元组。然后：

```python
code = ''.join(wubi98.rootSet[objectRoot.name] for objectRoot in scheme)
```

这里表示，我们取每个对象字根的名字（实际上此时变成了名义字根），然后用 `wubi98.rootSet` 转为编码，就完成了编码。

当然，实际的规则要略为复杂一些，例如我们如何对字根字进行编码呢？假设普通字根字的编码规则为：字根所在键位 + 第一、二、末笔。那么我们可以写：

```python
if len(scheme) == 1:
    objectRoot = scheme[0]
    nameRoot = objectRoot.name
    firstStroke = objectRoot.strokeList[0].type
    secondStroke = objectRoot.strokeList[1].type
    lastStroke = objectRoot.strokeList[-1].type
    info = [nameRoot, firstStroke, secondStroke, lastStroke]
    code = ''.join(wubi98.rootSet[nameRoot] for nameRoot in info)
```

哈！原来一个对象字根（`objectRoot`）不仅有名字属性，还有「笔画序列」（`strokeList`）属性。例如，`objectRoot.strokeList[0]` 就取到了该字的第一笔。每一笔都是一个 `Stroke` 对象，它具有一个 `type` 属性，如「横」，我们将它用 `rootSet` 进行映射，就得到了字根字的编码。

本系统还能轻而易举地完成识别码的添加。具体细节请看 GitHub 仓库中的 `wubi98.py`。

### 二分风格编码

待续。

### 二笔类编码

待续。

# 开发者文档

## 文件结构

如果您看到了这里，那么非常欢迎您参与「拆」的开发！在此之前，我们首先要了解文件结构：

- `Chai.py` 是主程序，其中定义了 `Schema` 类和 `Erbi` 类；
- `objects.py` 定义了笔画、字、树等对象；
- `preset.py` 定义了预设的退化映射和择优函数组件，其中笔画拓扑引用了 `topology.py` 中的算法；
- `tools.py` 定义了一些常用的函数；
- `文.yaml` 是基本部件的笔画信息表，来源于文泉驿；
- `字.yaml` 是将其他汉字分解为基本部件的信息表；
- `preset/` 是本系统内置的方案集，目前包括 98 五笔、指尖鸽码（分部风格形码）和轻星二笔。

## 处理对象

1. 对象笔画 Stroke：带有笔画名、控制点列描述的对象
2. 名义字 nameChar：字名、字根名
2. 对象字 objectChar：含有名义字、对象笔画列等信息的对象
3. 方案 Schema：用于加载数据并解析方案的对象，用户直接面向的对象

## 主要功能函数

1. 退化函数 degenerate
    - 功能：将对象字的笔画列进行降维，形成退化的可散列对象
    - 输入：对象字 objectChar
    - 输出：退化字 degenChar
2. 用户字根索引生成函数 dict_parse
    - 功能：按「文」数据解析出退化的用户字根，建立退化字根到字根的字典、字根到键位的字典
    - 输入：基础数据、用户方案
    - 输出：用户字根索引字典 degeneracy 、键位索引字典 rootSet
3. 幂集生成函数 get_power_dict
    - 功能：解析出基础字的所有有效切片，构造切片到用户对象字的字典
    - 输入：对象字 objectChar
    - 输出：将带幂集字典 powerDict 传给对象字 objectChar
4. 拆分器 decomposer
    - 功能：解析出在给定字根集下对象字的所有有效的拆分
    - 输入：带 powerDict 的对象字 objectChar
    - 输出：将可能拆分列 schemeList 传给对象字 objectChar
5. 估值函数 evaluator
    - 功能：对一个拆分进行估值
    - 输入：一个拆分 scheme
    - 输出：数 schemeEval
6. 优化函数 optimizer
    - 功能：找出估值列中的最值
    - 输入：拆分列的估值列
    - 输出：估值列的最值 bestEval
7. 选择函数 select
    - 功能：利用估值函数对一个拆分进行估值，然后利用优化函数将最优化的拆分筛选出来
    - 输入：带 schemeList 的对象字 objectChar
    - 输出：将在择优逻辑下最优拆分 bestScheme 传给对象字 objectChar
8. 基础字拆分索引生成器 wen_parse
    - 功能：解析出「文」数据库中字按拆分逻辑及用户定义字根拆分出的拆分列建立文数据库中字到拆分列的字典
    - 输入：基础数据、用户方案
    - 输出：基础字拆分索引字典 component
9. 取码函数（暂定） output
    - 功能：当方案对象经过解析后，通过迭代「字」中名义字，拆解嵌套表并取码，从而输出码表

## 拆分逻辑顺序

1. 读取基础数据库和用户方案数据
2. 按「文」数据退化用户字根，生成用户字根索引字典
    - 注，当用户字根不在文中时，用户应该在Alias中定义该字根
3. 将「文」中基础字按用户字根拆开，生成基础字拆分索引字典
4. 将「字」中的嵌套字迭代拆成基础字，从基础字拆分索引器中索引出以用户字根组成的拆分列
5. 对拆分列索引键位，完成取码

## `拆.py` 功能

1. 实例化一个方案解析器，同时加载用户方案和数据库：`schema = Schema('name')`
2. 解析方案 `schema.run()`
3. 取码 `schema.output()`
4. 设置退化函数 `schema.set_degen_func(退化函数)`
5. 添加选择器 `schema.set_selector(选择器名称, 估值函数, 优化函数)`

# 更新记录

## 0.1

经过一个月的艰苦奋斗，汉字自动拆分系统「拆」迎来了第一个预发布版本 `拆 0.1`！

请注意 `拆 1.0` 之前的版本全部为预发布版本，请避免将其应用于生产环境中，并报告所发现的一切问题。

### 💡️特性

1. 支持 GB 字集内全部汉字的自动拆分；
2. 支持以笔画种类和笔顺为基准建立退化映射；
3. 支持以「根少优先」「笔顺优先」「取大优先」为基准建立择优函数；
4. 以 98 五笔为例构造了测试实例。